// Generated by CoffeeScript 1.6.3
(function() {
  var SourceMap, callFunc, evalAlias, fs, getFunc, helpers, nodeTypes;

  fs = require('fs');

  helpers = require('./helpers');

  nodeTypes = require('./nodes');

  SourceMap = require('./sourcemap');

  evalAlias = eval;

  getFunc = function(funcNode) {
    var fragment, fragments, func;
    fragments = funcNode.compileToFragments({
      indent: ''
    });
    func = evalAlias('(' + ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        _results.push(fragment.code);
      }
      return _results;
    })()).join('') + ')');
    func.srcMap = new SourceMap(fragments);
    return func;
  };

  callFunc = function(func, obj, args, useLocation) {
    var e;
    if (args == null) {
      args = [];
    }
    try {
      return func.apply(obj, args);
    } catch (_error) {
      e = _error;
      if (e instanceof SyntaxError) {
        throw e;
      }
      e.srcMap = func.srcMap;
      return helpers.throwSyntaxError("run-time error in macro:\n" + e.stack, useLocation);
    }
  };

  callFunc.stopStackTrace = true;

  exports.expand = function(ast, csToNodes) {
    var context, getCalleeName, getMethodNameAndOwner, k, utils, v;
    root.cfg = context = {};
    root.macro = utils = {
      require: require,
      nodeToVal: function(node) {
        if (node) {
          return callFunc(getFunc(new this.Code([], new this.Block([node]))), context);
        }
      },
      nodeToId: function(node) {
        var _ref;
        if (node.base instanceof nodeTypes.Literal && node.isAssignable() && !((_ref = node.properties) != null ? _ref.length : void 0)) {
          return node.base.value;
        }
      },
      csToNode: function(code, filename) {
        return csToNodes(code, {
          filename: filename
        });
      },
      jsToNode: function(code) {
        return new nodeTypes.Literal(code || "void 0");
      },
      valToNode: function(expr) {
        return this.jsToNode(JSON.stringify(expr));
      },
      fileToNode: function(filename, lang) {
        var code;
        code = fs.readFileSync(filename, 'utf8');
        if (code.charCodeAt(0) === 0xFEFF) {
          code = code.substr(1);
        }
        if (lang === 'js' || (!lang && filename.match(/\.js$/))) {
          return this.jsToNode(code);
        } else {
          return this.csToNode(code, filename);
        }
      },
      _codeNodes: []
    };
    for (k in nodeTypes) {
      v = nodeTypes[k];
      utils[k] = v;
    }
    getCalleeName = function(node) {
      var name, prop, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (node instanceof nodeTypes.Call && (name = (_ref = node.variable) != null ? (_ref1 = _ref.base) != null ? _ref1.value : void 0 : void 0)) {
        _ref2 = node.variable.properties;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          prop = _ref2[_i];
          name += '.' + (prop != null ? (_ref3 = prop.name) != null ? _ref3.value : void 0 : void 0);
        }
        return name;
      }
    };
    getMethodNameAndOwner = function(node) {
      var name, owner, _ref, _ref1, _ref2;
      if (node instanceof nodeTypes.Call && (owner = (_ref = node.variable) != null ? _ref.properties : void 0) && (name = (_ref1 = owner[owner.length - 1]) != null ? (_ref2 = _ref1.name) != null ? _ref2.value : void 0 : void 0)) {
        owner = node.variable.subst({});
        owner.properties.pop();
        return [name, owner];
      } else {
        return [null, null];
      }
    };
    utils._macros = {
      macro: function(arg) {
        var name;
        if (arguments.length !== 1) {
          throw new Error("macro expects 1 argument, got " + arguments.length);
        }
        if (arg instanceof nodeTypes.Code) {
          if (arg.params.length) {
            throw new Error('macro expects a closure without parameters');
          }
          return callFunc(getFunc(arg), context);
        }
        if ((name = getCalleeName(arg))) {
          if (!(arg.args.length === 1 && arg.args[0] instanceof nodeTypes.Code)) {
            throw new Error("macro expects a closure after identifier");
          }
          utils._macros[name] = getFunc(arg.args[0]);
          return;
        }
        throw new Error("macro expects a closure or identifier");
      },
      "macro.defmethod": function(arg) {
        var name;
        if (arguments.length !== 1) {
          throw new Error("macro.defmethod expects 1 argument, got " + arguments.length);
        }
        if ((name = getCalleeName(arg))) {
          if (!(arg.args.length === 1 && arg.args[0] instanceof nodeTypes.Code)) {
            throw new Error("macro.defmethod expects a closure after identifier");
          }
          utils._methodMacros[name] = getFunc(arg.args[0]);
          return;
        }
        throw new Error("macro.defmethod expects a closure or identifier");
      },
      "macro.codeToNode": function(func) {
        var num;
        if (!(func instanceof nodeTypes.Code) || func.params.length) {
          throw new Error('macro.codeToNode expects a function (without arguments)');
        }
        num = utils._codeNodes.length;
        utils._codeNodes.push(func.body);
        return utils.jsToNode("macro._codeNodes[" + num + "]");
      }
    };
    utils._methodMacros = {};
    return nodeTypes.walk(ast, function(n) {
      var ld, name, owner, res, _ref;
      if (((name = getCalleeName(n)) && (utils._macros.hasOwnProperty(name))) || (_ref = getMethodNameAndOwner(n), name = _ref[0], owner = _ref[1], _ref) && (utils._methodMacros.hasOwnProperty(name))) {
        ld = n.locationData;
        utils.file = ld && helpers.filenames[ld.file_num];
        utils.line = ld && 1 + ld.first_line;
        res = owner != null ? (n.args.unshift(owner), callFunc(utils._methodMacros[name], context, n.args, ld)) : callFunc(utils._macros[name], context, n.args, ld);
        return (res instanceof nodeTypes.Base ? res : false);
      }
    });
  };

}).call(this);
