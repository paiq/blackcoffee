// Generated by CoffeeScript 1.8.0
(function() {
  var SourceMap, callFunc, evalAlias, fs, getFunc, helpers, nodeTypes;

  fs = require('fs');

  helpers = require('./helpers');

  nodeTypes = require('./nodes');

  SourceMap = require('./sourcemap');

  evalAlias = eval;

  getFunc = function(funcNode) {
    var fragment, fragments, func;
    fragments = funcNode.compileToFragments({
      indent: ''
    });
    func = evalAlias('(' + ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        _results.push(fragment.code);
      }
      return _results;
    })()).join('') + ')');
    func.srcMap = new SourceMap(fragments);
    return func;
  };

  callFunc = function(func, obj, args, useLocation) {
    var e;
    if (args == null) {
      args = [];
    }
    try {
      return func.apply(obj, args);
    } catch (_error) {
      e = _error;
      if (e instanceof SyntaxError) {
        throw e;
      }
      e.srcMap = func.srcMap;
      return helpers.throwSyntaxError("run-time error in macro:\n" + e.stack, useLocation);
    }
  };

  callFunc.stopStackTrace = true;

  exports.context = {};

  exports.utils = void 0;

  exports.expand = function(ast, csToNodes) {
    var context, getCalleeName, k, utils, v;
    getCalleeName = function(node) {
      var name, prop, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (node instanceof nodeTypes.Call && (name = (_ref = node.variable) != null ? (_ref1 = _ref.base) != null ? _ref1.value : void 0 : void 0)) {
        _ref2 = node.variable.properties;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          prop = _ref2[_i];
          name += '.' + (prop != null ? (_ref3 = prop.name) != null ? _ref3.value : void 0 : void 0);
        }
        return name;
      }
    };
    root.cfg = context = exports.context;
    if (!exports.utils) {
      root.macro = utils = {
        require: require,
        nodeToVal: function(node) {
          if (node) {
            return callFunc(getFunc(new this.Code([], new this.Block([node]))), context);
          }
        },
        nodeToId: function(node) {
          var _ref;
          if (node.base instanceof nodeTypes.Literal && node.isAssignable() && !((_ref = node.properties) != null ? _ref.length : void 0)) {
            return node.base.value;
          }
        },
        csToNode: function(code, filename) {
          return csToNodes(code, {
            filename: filename
          }).unwrap();
        },
        bcToNode: function(code, filename) {
          var oldfile, oldline;
          ast = csToNodes(code, {
            filename: filename
          }).unwrap();
          oldfile = utils.file;
          oldline = utils.line;
          ast = exports.expand(ast, csToNodes);
          utils.file = oldfile;
          utils.line = oldline;
          return ast;
        },
        jsToNode: function(code) {
          return new nodeTypes.Literal(code || "void 0");
        },
        valToNode: function(expr) {
          return this.jsToNode(JSON.stringify(expr));
        },
        fileToNode: function(filename, lang) {
          var code;
          code = fs.readFileSync(filename, 'utf8');
          if (code.charCodeAt(0) === 0xFEFF) {
            code = code.substr(1);
          }
          if (lang === 'js' || (!lang && filename.match(/\.js$/))) {
            return this.jsToNode(code);
          } else {
            return this.csToNode(code, filename);
          }
        },
        bcFileToNode: function(filename, lang) {
          var code;
          code = fs.readFileSync(filename, 'utf8');
          if (code.charCodeAt(0) === 0xFEFF) {
            code = code.substr(1);
          }
          code += "\nmacro ->";
          return this.bcToNode(code, filename);
        },
        _codeNodes: [],
        keep: {}
      };
      for (k in nodeTypes) {
        v = nodeTypes[k];
        utils[k] = v;
      }
      utils._macros = {
        macro: function(arg) {
          var name;
          if (arguments.length !== 1) {
            throw new Error("macro expects 1 argument, got " + arguments.length);
          }
          if (arg instanceof nodeTypes.Code) {
            if (arg.params.length) {
              throw new Error('macro expects a closure without parameters');
            }
            return callFunc(getFunc(arg), context);
          }
          if ((name = getCalleeName(arg))) {
            if (!(arg.args.length === 1 && arg.args[0] instanceof nodeTypes.Code)) {
              throw new Error("macro expects a closure after identifier");
            }
            utils._macros[name] = getFunc(arg.args[0]);
            return;
          }
          throw new Error("macro expects a closure or identifier");
        },
        "macro.codeToNode": function(func) {
          if (!(func instanceof nodeTypes.Code) || func.params.length) {
            throw new Error('macro.codeToNode expects a function (without arguments)');
          }
          utils._codeNodes.push(func.body.unwrap());
          return utils.jsToNode("macro._codeNodes[" + (utils._codeNodes.length - 1) + "]");
        }
      };
      exports.utils = utils;
    } else {
      root.macro = utils = exports.utils;
    }
    return nodeTypes.walk(ast, function(n) {
      var ld, name, res;
      if ((name = getCalleeName(n)) && utils._macros.hasOwnProperty(name)) {
        ld = n.locationData;
        utils.file = ld && helpers.filenames[ld.file_num];
        utils.line = ld && 1 + ld.first_line;
        res = callFunc(utils._macros[name], context, n.args, ld);
        if (res === utils.keep) {
          return true;
        } else if (res instanceof nodeTypes.Base) {
          return res;
        } else {
          return false;
        }
      }
    });
  };

}).call(this);
